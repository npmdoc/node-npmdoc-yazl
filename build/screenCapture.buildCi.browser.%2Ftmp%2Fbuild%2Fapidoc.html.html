<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/thejoshwolfe/yazl">yazl (v2.4.2)</a>
</h1>
<h4>yet another zip library for node</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.yazl">module yazl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile">
            function <span class="apidocSignatureSpan">yazl.</span>ZipFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.addBuffer">
            function <span class="apidocSignatureSpan">yazl.</span>ZipFile.prototype.addBuffer
            <span class="apidocSignatureSpan">(buffer, metadataPath, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.addEmptyDirectory">
            function <span class="apidocSignatureSpan">yazl.</span>ZipFile.prototype.addEmptyDirectory
            <span class="apidocSignatureSpan">(metadataPath, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.addFile">
            function <span class="apidocSignatureSpan">yazl.</span>ZipFile.prototype.addFile
            <span class="apidocSignatureSpan">(realPath, metadataPath, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.addReadStream">
            function <span class="apidocSignatureSpan">yazl.</span>ZipFile.prototype.addReadStream
            <span class="apidocSignatureSpan">(readStream, metadataPath, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.end">
            function <span class="apidocSignatureSpan">yazl.</span>ZipFile.prototype.end
            <span class="apidocSignatureSpan">(options, finalSizeCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.dateToDosDateTime">
            function <span class="apidocSignatureSpan">yazl.</span>dateToDosDateTime
            <span class="apidocSignatureSpan">(jsDate)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yazl.</span>ZipFile.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yazl.ZipFile">module yazl.ZipFile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.ZipFile">
            function <span class="apidocSignatureSpan">yazl.</span>ZipFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.super_">
            function <span class="apidocSignatureSpan">yazl.ZipFile.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yazl.ZipFile.prototype">module yazl.ZipFile.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.addBuffer">
            function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addBuffer
            <span class="apidocSignatureSpan">(buffer, metadataPath, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.addEmptyDirectory">
            function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addEmptyDirectory
            <span class="apidocSignatureSpan">(metadataPath, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.addFile">
            function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addFile
            <span class="apidocSignatureSpan">(realPath, metadataPath, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.addReadStream">
            function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addReadStream
            <span class="apidocSignatureSpan">(readStream, metadataPath, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.end">
            function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>end
            <span class="apidocSignatureSpan">(options, finalSizeCallback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yazl.ZipFile.prototype.addBuffer">module yazl.ZipFile.prototype.addBuffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.addBuffer.addBuffer">
            function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addBuffer
            <span class="apidocSignatureSpan">(buffer, metadataPath, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yazl.ZipFile.prototype.addEmptyDirectory">module yazl.ZipFile.prototype.addEmptyDirectory</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.addEmptyDirectory.addEmptyDirectory">
            function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addEmptyDirectory
            <span class="apidocSignatureSpan">(metadataPath, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yazl.ZipFile.prototype.addFile">module yazl.ZipFile.prototype.addFile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.addFile.addFile">
            function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addFile
            <span class="apidocSignatureSpan">(realPath, metadataPath, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yazl.ZipFile.prototype.addReadStream">module yazl.ZipFile.prototype.addReadStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.addReadStream.addReadStream">
            function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addReadStream
            <span class="apidocSignatureSpan">(readStream, metadataPath, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yazl.ZipFile.prototype.end">module yazl.ZipFile.prototype.end</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.ZipFile.prototype.end.end">
            function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>end
            <span class="apidocSignatureSpan">(options, finalSizeCallback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yazl.dateToDosDateTime">module yazl.dateToDosDateTime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yazl.dateToDosDateTime.dateToDosDateTime">
            function <span class="apidocSignatureSpan">yazl.</span>dateToDosDateTime
            <span class="apidocSignatureSpan">(jsDate)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yazl" id="apidoc.module.yazl">module yazl</a></h1>


    <h2>
        <a href="#apidoc.element.yazl.ZipFile" id="apidoc.element.yazl.ZipFile">
        function <span class="apidocSignatureSpan">yazl.</span>ZipFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ZipFile() {
  this.outputStream = new PassThrough();
  this.entries = [];
  this.outputStreamCursor = 0;
  this.ended = false; // .end() sets this
  this.allDone = false; // set when we've written the last bytes
  this.forceZip64Eocd = false; // configurable in .end()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   but avoids OS-imposed limits on the number of simultaneously open file handles.

## Usage

```js
var yazl = require("yazl");

var zipfile = new yazl.<span class="apidocCodeKeywordSpan">ZipFile</span>();
zipfile.addFile("file1.txt", "file1.txt");
// (add only files, not directories)
zipfile.addFile("path/to/file.txt", "path/in/zipfile.txt");
// pipe() can be called any time after the constructor
zipfile.outputStream.pipe(fs.createWriteStream("output.zip")).on("close", function() {
  console.log("done");
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.addBuffer" id="apidoc.element.yazl.ZipFile.prototype.addBuffer">
        function <span class="apidocSignatureSpan">yazl.</span>ZipFile.prototype.addBuffer
        <span class="apidocSignatureSpan">(buffer, metadataPath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ZipFile.prototype.addBuffer = function (buffer, metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (buffer.length &gt; 0x3fffffff) throw new Error("buffer too large: " + buffer.length + " &gt; " + 0x3fffffff);
  if (options == null) options = {};
  if (options.size != null) throw new Error("options.size not allowed");
  var entry = new Entry(metadataPath, false, options);
  entry.uncompressedSize = buffer.length;
  entry.crc32 = crc32.unsigned(buffer);
  entry.crcAndFileSizeKnown = true;
  self.entries.push(entry);
  if (!entry.compress) {
    setCompressedBuffer(buffer);
  } else {
    zlib.deflateRaw(buffer, function(err, compressedBuffer) {
      setCompressedBuffer(compressedBuffer);
    });
  }
  function setCompressedBuffer(compressedBuffer) {
    entry.compressedSize = compressedBuffer.length;
    entry.setFileDataPumpFunction(function() {
      writeToOutputStream(self, compressedBuffer);
      writeToOutputStream(self, entry.getDataDescriptor());
      entry.state = Entry.FILE_DATA_DONE;

      // don't call pumpEntries() recursively.
      // (also, don't call process.nextTick recursively.)
      setImmediate(function() {
        pumpEntries(self);
      });
    });
    pumpEntries(self);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.addEmptyDirectory" id="apidoc.element.yazl.ZipFile.prototype.addEmptyDirectory">
        function <span class="apidocSignatureSpan">yazl.</span>ZipFile.prototype.addEmptyDirectory
        <span class="apidocSignatureSpan">(metadataPath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ZipFile.prototype.addEmptyDirectory = function (metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, true);
  if (options == null) options = {};
  if (options.size != null) throw new Error("options.size not allowed");
  if (options.compress != null) throw new Error("options.compress not allowed");
  var entry = new Entry(metadataPath, true, options);
  self.entries.push(entry);
  entry.setFileDataPumpFunction(function() {
    writeToOutputStream(self, entry.getDataDescriptor());
    entry.state = Entry.FILE_DATA_DONE;
    pumpEntries(self);
  });
  pumpEntries(self);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.addFile" id="apidoc.element.yazl.ZipFile.prototype.addFile">
        function <span class="apidocSignatureSpan">yazl.</span>ZipFile.prototype.addFile
        <span class="apidocSignatureSpan">(realPath, metadataPath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ZipFile.prototype.addFile = function (realPath, metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (options == null) options = {};

  var entry = new Entry(metadataPath, false, options);
  self.entries.push(entry);
  fs.stat(realPath, function(err, stats) {
    if (err) return self.emit("error", err);
    if (!stats.isFile()) return self.emit("error", new Error("not a file: " + realPath));
    entry.uncompressedSize = stats.size;
    if (options.mtime == null) entry.setLastModDate(stats.mtime);
    if (options.mode == null) entry.setFileAttributesMode(stats.mode);
    entry.setFileDataPumpFunction(function() {
      var readStream = fs.createReadStream(realPath);
      entry.state = Entry.FILE_DATA_IN_PROGRESS;
      readStream.on("error", function(err) {
        self.emit("error", err);
      });
      pumpFileDataReadStream(self, entry, readStream);
    });
    pumpEntries(self);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.addReadStream" id="apidoc.element.yazl.ZipFile.prototype.addReadStream">
        function <span class="apidocSignatureSpan">yazl.</span>ZipFile.prototype.addReadStream
        <span class="apidocSignatureSpan">(readStream, metadataPath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ZipFile.prototype.addReadStream = function (readStream, metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (options == null) options = {};
  var entry = new Entry(metadataPath, false, options);
  self.entries.push(entry);
  entry.setFileDataPumpFunction(function() {
    entry.state = Entry.FILE_DATA_IN_PROGRESS;
    pumpFileDataReadStream(self, entry, readStream);
  });
  pumpEntries(self);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.end" id="apidoc.element.yazl.ZipFile.prototype.end">
        function <span class="apidocSignatureSpan">yazl.</span>ZipFile.prototype.end
        <span class="apidocSignatureSpan">(options, finalSizeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ZipFile.prototype.end = function (options, finalSizeCallback) {
  if (typeof options === "function") {
    finalSizeCallback = options;
    options = null;
  }
  if (options == null) options = {};
  if (this.ended) return;
  this.ended = true;
  this.finalSizeCallback = finalSizeCallback;
  this.forceZip64Eocd = !!options.forceZip64Format;
  pumpEntries(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yazl.dateToDosDateTime" id="apidoc.element.yazl.dateToDosDateTime">
        function <span class="apidocSignatureSpan">yazl.</span>dateToDosDateTime
        <span class="apidocSignatureSpan">(jsDate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dateToDosDateTime(jsDate) {
  var date = 0;
  date |= jsDate.getDate() &amp; 0x1f; // 1-31
  date |= ((jsDate.getMonth() + 1) &amp; 0xf) &lt;&lt; 5; // 0-11, 1-12
  date |= ((jsDate.getFullYear() - 1980) &amp; 0x7f) &lt;&lt; 9; // 0-128, 1980-2108

  var time = 0;
  time |= Math.floor(jsDate.getSeconds() / 2); // 0-59, 0-29 (lose odd numbers)
  time |= (jsDate.getMinutes() &amp; 0x3f) &lt;&lt; 5; // 0-59
  time |= (jsDate.getHours() &amp; 0x1f) &lt;&lt; 11; // 0-23

  return {date: date, time: time};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yazl.ZipFile" id="apidoc.module.yazl.ZipFile">module yazl.ZipFile</a></h1>


    <h2>
        <a href="#apidoc.element.yazl.ZipFile.ZipFile" id="apidoc.element.yazl.ZipFile.ZipFile">
        function <span class="apidocSignatureSpan">yazl.</span>ZipFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ZipFile() {
  this.outputStream = new PassThrough();
  this.entries = [];
  this.outputStreamCursor = 0;
  this.ended = false; // .end() sets this
  this.allDone = false; // set when we've written the last bytes
  this.forceZip64Eocd = false; // configurable in .end()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   but avoids OS-imposed limits on the number of simultaneously open file handles.

## Usage

```js
var yazl = require("yazl");

var zipfile = new yazl.<span class="apidocCodeKeywordSpan">ZipFile</span>();
zipfile.addFile("file1.txt", "file1.txt");
// (add only files, not directories)
zipfile.addFile("path/to/file.txt", "path/in/zipfile.txt");
// pipe() can be called any time after the constructor
zipfile.outputStream.pipe(fs.createWriteStream("output.zip")).on("close", function() {
  console.log("done");
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yazl.ZipFile.super_" id="apidoc.element.yazl.ZipFile.super_">
        function <span class="apidocSignatureSpan">yazl.ZipFile.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yazl.ZipFile.prototype" id="apidoc.module.yazl.ZipFile.prototype">module yazl.ZipFile.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.addBuffer" id="apidoc.element.yazl.ZipFile.prototype.addBuffer">
        function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addBuffer
        <span class="apidocSignatureSpan">(buffer, metadataPath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBuffer = function (buffer, metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (buffer.length &gt; 0x3fffffff) throw new Error("buffer too large: " + buffer.length + " &gt; " + 0x3fffffff);
  if (options == null) options = {};
  if (options.size != null) throw new Error("options.size not allowed");
  var entry = new Entry(metadataPath, false, options);
  entry.uncompressedSize = buffer.length;
  entry.crc32 = crc32.unsigned(buffer);
  entry.crcAndFileSizeKnown = true;
  self.entries.push(entry);
  if (!entry.compress) {
    setCompressedBuffer(buffer);
  } else {
    zlib.deflateRaw(buffer, function(err, compressedBuffer) {
      setCompressedBuffer(compressedBuffer);
    });
  }
  function setCompressedBuffer(compressedBuffer) {
    entry.compressedSize = compressedBuffer.length;
    entry.setFileDataPumpFunction(function() {
      writeToOutputStream(self, compressedBuffer);
      writeToOutputStream(self, entry.getDataDescriptor());
      entry.state = Entry.FILE_DATA_DONE;

      // don't call pumpEntries() recursively.
      // (also, don't call process.nextTick recursively.)
      setImmediate(function() {
        pumpEntries(self);
      });
    });
    pumpEntries(self);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.log("done");
});
// alternate apis for adding files:
zipfile.addReadStream(process.stdin, "stdin.txt", {
  mtime: new Date(),
  mode: parseInt("0100664", 8), // -rw-rw-r--
});
zipfile.<span class="apidocCodeKeywordSpan">addBuffer</span>(new Buffer("hello"), "hello.txt", {
  mtime: new Date(),
  mode: parseInt("0100664", 8), // -rw-rw-r--
});
// call end() after all the files have been added
zipfile.end();
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.addEmptyDirectory" id="apidoc.element.yazl.ZipFile.prototype.addEmptyDirectory">
        function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addEmptyDirectory
        <span class="apidocSignatureSpan">(metadataPath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addEmptyDirectory = function (metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, true);
  if (options == null) options = {};
  if (options.size != null) throw new Error("options.size not allowed");
  if (options.compress != null) throw new Error("options.compress not allowed");
  var entry = new Entry(metadataPath, true, options);
  self.entries.push(entry);
  entry.setFileDataPumpFunction(function() {
    writeToOutputStream(self, entry.getDataDescriptor());
    entry.state = Entry.FILE_DATA_DONE;
    pumpEntries(self);
  });
  pumpEntries(self);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.addFile" id="apidoc.element.yazl.ZipFile.prototype.addFile">
        function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addFile
        <span class="apidocSignatureSpan">(realPath, metadataPath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addFile = function (realPath, metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (options == null) options = {};

  var entry = new Entry(metadataPath, false, options);
  self.entries.push(entry);
  fs.stat(realPath, function(err, stats) {
    if (err) return self.emit("error", err);
    if (!stats.isFile()) return self.emit("error", new Error("not a file: " + realPath));
    entry.uncompressedSize = stats.size;
    if (options.mtime == null) entry.setLastModDate(stats.mtime);
    if (options.mode == null) entry.setFileAttributesMode(stats.mode);
    entry.setFileDataPumpFunction(function() {
      var readStream = fs.createReadStream(realPath);
      entry.state = Entry.FILE_DATA_IN_PROGRESS;
      readStream.on("error", function(err) {
        self.emit("error", err);
      });
      pumpFileDataReadStream(self, entry, readStream);
    });
    pumpEntries(self);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Usage

```js
var yazl = require("yazl");

var zipfile = new yazl.ZipFile();
zipfile.<span class="apidocCodeKeywordSpan">addFile</span>("file1.txt", "file1.txt");
// (add only files, not directories)
zipfile.addFile("path/to/file.txt", "path/in/zipfile.txt");
// pipe() can be called any time after the constructor
zipfile.outputStream.pipe(fs.createWriteStream("output.zip")).on("close", function() {
  console.log("done");
});
// alternate apis for adding files:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.addReadStream" id="apidoc.element.yazl.ZipFile.prototype.addReadStream">
        function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addReadStream
        <span class="apidocSignatureSpan">(readStream, metadataPath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addReadStream = function (readStream, metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (options == null) options = {};
  var entry = new Entry(metadataPath, false, options);
  self.entries.push(entry);
  entry.setFileDataPumpFunction(function() {
    entry.state = Entry.FILE_DATA_IN_PROGRESS;
    pumpFileDataReadStream(self, entry, readStream);
  });
  pumpEntries(self);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// (add only files, not directories)
zipfile.addFile("path/to/file.txt", "path/in/zipfile.txt");
// pipe() can be called any time after the constructor
zipfile.outputStream.pipe(fs.createWriteStream("output.zip")).on("close", function() {
  console.log("done");
});
// alternate apis for adding files:
zipfile.<span class="apidocCodeKeywordSpan">addReadStream</span>(process.stdin, "stdin.txt", {
  mtime: new Date(),
  mode: parseInt("0100664", 8), // -rw-rw-r--
});
zipfile.addBuffer(new Buffer("hello"), "hello.txt", {
  mtime: new Date(),
  mode: parseInt("0100664", 8), // -rw-rw-r--
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.end" id="apidoc.element.yazl.ZipFile.prototype.end">
        function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>end
        <span class="apidocSignatureSpan">(options, finalSizeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (options, finalSizeCallback) {
  if (typeof options === "function") {
    finalSizeCallback = options;
    options = null;
  }
  if (options == null) options = {};
  if (this.ended) return;
  this.ended = true;
  this.finalSizeCallback = finalSizeCallback;
  this.forceZip64Eocd = !!options.forceZip64Format;
  pumpEntries(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  mode: parseInt("0100664", 8), // -rw-rw-r--
});
zipfile.addBuffer(new Buffer("hello"), "hello.txt", {
  mtime: new Date(),
  mode: parseInt("0100664", 8), // -rw-rw-r--
});
// call end() after all the files have been added
zipfile.<span class="apidocCodeKeywordSpan">end</span>();
```

## API

### Class: ZipFile

#### new ZipFile()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yazl.ZipFile.prototype.addBuffer" id="apidoc.module.yazl.ZipFile.prototype.addBuffer">module yazl.ZipFile.prototype.addBuffer</a></h1>


    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.addBuffer.addBuffer" id="apidoc.element.yazl.ZipFile.prototype.addBuffer.addBuffer">
        function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addBuffer
        <span class="apidocSignatureSpan">(buffer, metadataPath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBuffer = function (buffer, metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (buffer.length &gt; 0x3fffffff) throw new Error("buffer too large: " + buffer.length + " &gt; " + 0x3fffffff);
  if (options == null) options = {};
  if (options.size != null) throw new Error("options.size not allowed");
  var entry = new Entry(metadataPath, false, options);
  entry.uncompressedSize = buffer.length;
  entry.crc32 = crc32.unsigned(buffer);
  entry.crcAndFileSizeKnown = true;
  self.entries.push(entry);
  if (!entry.compress) {
    setCompressedBuffer(buffer);
  } else {
    zlib.deflateRaw(buffer, function(err, compressedBuffer) {
      setCompressedBuffer(compressedBuffer);
    });
  }
  function setCompressedBuffer(compressedBuffer) {
    entry.compressedSize = compressedBuffer.length;
    entry.setFileDataPumpFunction(function() {
      writeToOutputStream(self, compressedBuffer);
      writeToOutputStream(self, entry.getDataDescriptor());
      entry.state = Entry.FILE_DATA_DONE;

      // don't call pumpEntries() recursively.
      // (also, don't call process.nextTick recursively.)
      setImmediate(function() {
        pumpEntries(self);
      });
    });
    pumpEntries(self);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.log("done");
});
// alternate apis for adding files:
zipfile.addReadStream(process.stdin, "stdin.txt", {
  mtime: new Date(),
  mode: parseInt("0100664", 8), // -rw-rw-r--
});
zipfile.<span class="apidocCodeKeywordSpan">addBuffer</span>(new Buffer("hello"), "hello.txt", {
  mtime: new Date(),
  mode: parseInt("0100664", 8), // -rw-rw-r--
});
// call end() after all the files have been added
zipfile.end();
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yazl.ZipFile.prototype.addEmptyDirectory" id="apidoc.module.yazl.ZipFile.prototype.addEmptyDirectory">module yazl.ZipFile.prototype.addEmptyDirectory</a></h1>


    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.addEmptyDirectory.addEmptyDirectory" id="apidoc.element.yazl.ZipFile.prototype.addEmptyDirectory.addEmptyDirectory">
        function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addEmptyDirectory
        <span class="apidocSignatureSpan">(metadataPath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addEmptyDirectory = function (metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, true);
  if (options == null) options = {};
  if (options.size != null) throw new Error("options.size not allowed");
  if (options.compress != null) throw new Error("options.compress not allowed");
  var entry = new Entry(metadataPath, true, options);
  self.entries.push(entry);
  entry.setFileDataPumpFunction(function() {
    writeToOutputStream(self, entry.getDataDescriptor());
    entry.state = Entry.FILE_DATA_DONE;
    pumpEntries(self);
  });
  pumpEntries(self);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yazl.ZipFile.prototype.addFile" id="apidoc.module.yazl.ZipFile.prototype.addFile">module yazl.ZipFile.prototype.addFile</a></h1>


    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.addFile.addFile" id="apidoc.element.yazl.ZipFile.prototype.addFile.addFile">
        function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addFile
        <span class="apidocSignatureSpan">(realPath, metadataPath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addFile = function (realPath, metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (options == null) options = {};

  var entry = new Entry(metadataPath, false, options);
  self.entries.push(entry);
  fs.stat(realPath, function(err, stats) {
    if (err) return self.emit("error", err);
    if (!stats.isFile()) return self.emit("error", new Error("not a file: " + realPath));
    entry.uncompressedSize = stats.size;
    if (options.mtime == null) entry.setLastModDate(stats.mtime);
    if (options.mode == null) entry.setFileAttributesMode(stats.mode);
    entry.setFileDataPumpFunction(function() {
      var readStream = fs.createReadStream(realPath);
      entry.state = Entry.FILE_DATA_IN_PROGRESS;
      readStream.on("error", function(err) {
        self.emit("error", err);
      });
      pumpFileDataReadStream(self, entry, readStream);
    });
    pumpEntries(self);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Usage

```js
var yazl = require("yazl");

var zipfile = new yazl.ZipFile();
zipfile.<span class="apidocCodeKeywordSpan">addFile</span>("file1.txt", "file1.txt");
// (add only files, not directories)
zipfile.addFile("path/to/file.txt", "path/in/zipfile.txt");
// pipe() can be called any time after the constructor
zipfile.outputStream.pipe(fs.createWriteStream("output.zip")).on("close", function() {
  console.log("done");
});
// alternate apis for adding files:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yazl.ZipFile.prototype.addReadStream" id="apidoc.module.yazl.ZipFile.prototype.addReadStream">module yazl.ZipFile.prototype.addReadStream</a></h1>


    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.addReadStream.addReadStream" id="apidoc.element.yazl.ZipFile.prototype.addReadStream.addReadStream">
        function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>addReadStream
        <span class="apidocSignatureSpan">(readStream, metadataPath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addReadStream = function (readStream, metadataPath, options) {
  var self = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (options == null) options = {};
  var entry = new Entry(metadataPath, false, options);
  self.entries.push(entry);
  entry.setFileDataPumpFunction(function() {
    entry.state = Entry.FILE_DATA_IN_PROGRESS;
    pumpFileDataReadStream(self, entry, readStream);
  });
  pumpEntries(self);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// (add only files, not directories)
zipfile.addFile("path/to/file.txt", "path/in/zipfile.txt");
// pipe() can be called any time after the constructor
zipfile.outputStream.pipe(fs.createWriteStream("output.zip")).on("close", function() {
  console.log("done");
});
// alternate apis for adding files:
zipfile.<span class="apidocCodeKeywordSpan">addReadStream</span>(process.stdin, "stdin.txt", {
  mtime: new Date(),
  mode: parseInt("0100664", 8), // -rw-rw-r--
});
zipfile.addBuffer(new Buffer("hello"), "hello.txt", {
  mtime: new Date(),
  mode: parseInt("0100664", 8), // -rw-rw-r--
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yazl.ZipFile.prototype.end" id="apidoc.module.yazl.ZipFile.prototype.end">module yazl.ZipFile.prototype.end</a></h1>


    <h2>
        <a href="#apidoc.element.yazl.ZipFile.prototype.end.end" id="apidoc.element.yazl.ZipFile.prototype.end.end">
        function <span class="apidocSignatureSpan">yazl.ZipFile.prototype.</span>end
        <span class="apidocSignatureSpan">(options, finalSizeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (options, finalSizeCallback) {
  if (typeof options === "function") {
    finalSizeCallback = options;
    options = null;
  }
  if (options == null) options = {};
  if (this.ended) return;
  this.ended = true;
  this.finalSizeCallback = finalSizeCallback;
  this.forceZip64Eocd = !!options.forceZip64Format;
  pumpEntries(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  mode: parseInt("0100664", 8), // -rw-rw-r--
});
zipfile.addBuffer(new Buffer("hello"), "hello.txt", {
  mtime: new Date(),
  mode: parseInt("0100664", 8), // -rw-rw-r--
});
// call end() after all the files have been added
zipfile.<span class="apidocCodeKeywordSpan">end</span>();
```

## API

### Class: ZipFile

#### new ZipFile()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yazl.dateToDosDateTime" id="apidoc.module.yazl.dateToDosDateTime">module yazl.dateToDosDateTime</a></h1>


    <h2>
        <a href="#apidoc.element.yazl.dateToDosDateTime.dateToDosDateTime" id="apidoc.element.yazl.dateToDosDateTime.dateToDosDateTime">
        function <span class="apidocSignatureSpan">yazl.</span>dateToDosDateTime
        <span class="apidocSignatureSpan">(jsDate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dateToDosDateTime(jsDate) {
  var date = 0;
  date |= jsDate.getDate() &amp; 0x1f; // 1-31
  date |= ((jsDate.getMonth() + 1) &amp; 0xf) &lt;&lt; 5; // 0-11, 1-12
  date |= ((jsDate.getFullYear() - 1980) &amp; 0x7f) &lt;&lt; 9; // 0-128, 1980-2108

  var time = 0;
  time |= Math.floor(jsDate.getSeconds() / 2); // 0-59, 0-29 (lose odd numbers)
  time |= (jsDate.getMinutes() &amp; 0x3f) &lt;&lt; 5; // 0-59
  time |= (jsDate.getHours() &amp; 0x1f) &lt;&lt; 11; // 0-23

  return {date: date, time: time};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>